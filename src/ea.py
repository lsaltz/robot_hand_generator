# Apapted from Josh Campbell by Marshall Saltz

import random
import numpy as np
import os
import json
import mutations
from addict import Dict
import combination
import testing
import glob
import time
import main
from pathlib import Path
import basic_load

finger_0 = "finger_0"
finger_1 = "finger_1"
mutateTimes = 5 #Amount of mutated files per generation
file_name = []  #file name of hands
fitness = []    #Array for storing all hand fitnesses, determined by ability to grasp a sphere of a fixed size
max_segs = 10   #Max amount of segments per hand
ext = ('.json')
print("Please input the integer number of generations you would like to run this for: ")
gen = int(input())  #generations ea runs for
for num in range(gen):  #run the script for num generations
    combine = combination.crossoverFunctions(gen)
    mutations.mutate(mutateTimes, max_segs, gen)
    
    main.MainScript()   

    
    file_content = testing.read_json("./../src/.user_info.json")
    location = "../hand_json_files/hand_queue_json/"
    
    directory = os.getcwd()

    file_content = testing.read_json("./../src/.user_info.json")


    folder = os.path.dirname("../output/")
    """
    The loop below loops through all urdf files, tests them, and adds them to a list along
    with their fitness scores.
    """
    for root, dirs, files in os.walk(folder):
        for file in files:
            if file.endswith('.urdf'):
                hand_name = os.path.basename((file).split('.')[0])
            
                print("hand_name: ", hand_name)
                hand_loc = root
                print("hand_loc: ", hand_loc)
                sim_test = testing.sim_tester(hand_name, hand_loc)
                file_name.append(hand_name + ".json")
                startTime = time.time()
                fitness.append(sim_test.main(startTime))
                print("Fitness for " + str(hand_name) + " is: " + str(fitness[-1]))
            
    print("file_name: ", file_name)
    print("fitness: ", fitness)
    
    scoring = np.array(list(zip(fitness, file_name)))   #Combines fitness scores with their files
    sortedScoring = scoring[scoring[:,0].astype(int).argsort()] #Sorts array by fittness scores

    fittestFirst = sortedScoring[-1][1] #Highest
    secondFittest = sortedScoring[-2][1]    #and second highest files
    
    
    print("first highest: ", str(fittestFirst))
    print("second highest: ", str(secondFittest))
    
    """
    Below calls all of the methods in combination. First, it turns the jsons into
    dictionaries. Next, it counts their segments. Then, it compares the segment counts and decides how to crossover the two files based on that.
    """
   
    f0 = os.path.expanduser('~/robot_hand_generator_MLS/hand_json_files/hand_archive_json/') + str(fittestFirst)
    par0 = combine.json_to_dictionaries(f0)
    
    f1 = os.path.expanduser('~/robot_hand_generator_MLS/hand_json_files/hand_archive_json/') + str(secondFittest)
    par1 = combine.json_to_dictionaries(f1)

    count_0_0, count_0_1 = combine.segment_counter(par0)
    count_1_0, count_1_1 = combine.segment_counter(par1)
    print("Gen 0 finger 0: ", count_0_0)
    print("Gen 1 finger 0: ", count_1_0)
    print("Gen 0 finger 1: ", count_0_1)
    print("Gen 1 finger 1: ", count_1_1)

    crossover0_0, crossover1_0 = combine.segment_count_comparator(par0, par1, count_0_0, count_1_0, finger_0)
    crossover0_1, crossover1_1 = combine.segment_count_comparator(par0, par1, count_0_1, count_1_1, finger_1)

    combine.write_to_json(crossover0_0, crossover0_1, 0)
    combine.write_to_json(crossover1_0, crossover1_1, 1)
    
    main.MainScript()
    
    file_content = testing.read_json("./../src/.user_info.json")
    location = os.path.expanduser("~/robot_hand_generator_MLS/hand_json_files/hand_queue_json/")
    
    directory = os.getcwd()

    file_content = testing.read_json("./../src/.user_info.json")

    folder = os.path.dirname("../output/")
    
    """
    Below walks through the urdf files generated by main and tests them,
    returning their fitness scores and file names as lists which it then
    combines into an array which is then sorted.
    """
    
    for root, dirs, files in os.walk(folder):
        for file in files:
            if file.endswith('.urdf'):
                hand_name = os.path.basename((file).split('.')[0])
            
                print("hand_name: ", hand_name)
                hand_loc = root
                print("hand_loc: ", hand_loc)
                sim_test = testing.sim_tester(hand_name, hand_loc)
        
                file_name.append(hand_name + ".json")
                startTime = time.time()
                fitness.append(sim_test.main(startTime))
                print("Fitness for " + str(hand_name) + " is: " + str(fitness[-1]))
         
    scoring = np.array(list(zip(fitness, file_name)))
    
    sortedScoring = scoring[scoring[:,0].astype(int).argsort()]

    fittestFirst = sortedScoring[-1][1]
    secondFittest = sortedScoring[-2][1]
    
    print(sortedScoring)
"""
Below all of the urdf files are removed.
The winning file is selected and moved to the queue, and main is run again.
This generates a urdf for the winning json. Then, a results file with the data collected
is generated and the winning urdf is opened with pybullet. If you would like to view
the other files, they need to be added to the queue from archive and main needs to be run,
then the simulation code in pybullet_playground.
"""
print("The fittest of them all is: ", str(fittestFirst))
print("Runner up is: ", str(secondFittest))

clearing_path = "../output/"

old_location = "../hand_json_files/hand_archive_json/" + str(fittestFirst)
new_location = "../hand_json_files/hand_queue_json/" + str(fittestFirst)

os.rename(old_location, new_location)


for root, dirs, files in os.walk(clearing_path):
    for file in files:
        os.remove(os.path.join(root, file))


main.MainScript() 
for root, dirs, files in os.walk(clearing_path):
    for file in files:
        if file.endswith('.urdf'):
            hand_name = os.path.basename(file)

            hand_loc = root
            
            fittest_file = os.path.join(root, hand_name)

with open("../results.txt", mode="w") as resultsFile:
    resultsFile.write("The fittest of them all is: " + str(fittestFirst) + "\n")
    resultsFile.write("Location is: " + str(root) + "\n")
    resultsFile.write("Runner up is: " + str(secondFittest) + "\n")
    resultsFile.write("Overall results are: \n" + str(sortedScoring) + "\n")
    resultsFile.close()

basic_load.load(fittest_file)